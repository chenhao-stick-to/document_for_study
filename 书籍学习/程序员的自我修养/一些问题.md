# 第一部分 序章
- 问题一：IDE接口和设备驱动程序的关系
- 问题二：Linux新任务的产生，写时复制（COW，copy on write）
- 问题三：在线程安全中，为什么编译器将加锁变量放入不同的的寄存器中，加锁的特性（即加锁变量分别存储在不同寄存器中，锁会失效）会失效？P28
- 问题四：可重入函数和线程安全，单例模式，阻止编译器优化（volatile关键字，阻止换序的CPU指令）
# 第二部分 静态链接
## 第二章
- 问题五：编译器从.i文件到编译后文件.s的词法，语法，语义以及一些优化的具体详细过程
- 问题六：编译器gcc/g++的后台操作和ccl/as/ld这些编译后台程序的关联性，什么样的参数对应者什么样的编译后台程序控制
## 第四章/第六章
- 问题七：代码重复消除具体有哪些类型和操作？
- 问题八：main函数之前和之后，系统做了哪些事？
- 问题九：函数参数入栈顺序，以及返回值的归途？
- 问题10：弄清楚c运行时库，c标准库，系统调用联系
- 问题11：binutils库以及其中的bfd库的用途？
- 问题12：宏定义定义的变量以及函数展开（预编译时）。内联函数的函数展开（编译时），和普通函数不一样，也在符号表中有，但是会检查类型正确性，正确则会将函数代码直接展开（编译器自己优化确定，即使指定了inline），而不是那种入口地址的函数调用。宏函数/内联函数/普通函数三者在编译汇编链接过程中的不同点？
- 问题13：对于随机地址空间分布技术的实现，linux详细了解？
## 第7章
问题14： 动态链接怎样影响进程虚拟地址空间分布，存储管理，内存共享以及进程线程等机制的？
问题15：动态链接时，os怎样找到系统中为什么已存在程序所需的共享库，（扫描链接器配置文件？）
问题16：在链接器找到内存中存在的共享库后，又怎样做，物理地址和程序虚拟地址的对应映射呢？==和静态链接区别==