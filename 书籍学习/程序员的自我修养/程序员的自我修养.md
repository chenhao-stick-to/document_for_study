# 大致规划：
2023.9.15 简介
2023.9.16-9.17 静态装载
2023.9.18-9.20 动态装载
2023.9.21-9.24 库与运行库
# 第一部分 序章

## 早期计算机架构

无论是低速设备（键盘，鼠标等），还是高速设备（磁盘，cpu等）都连在一个bus总线上，为了协调各设备的速度以及让cpu和各设备通信，故每个设备需要一个IO控制器。

cpu核心频率的增高，内存跟不上，产生了与内存频率一致的总线。

为协调cpu，内存，高速图形设备，北桥芯片产生。低速设备一起连接？复杂，故

设计了南桥芯片，采用PCI/ISA总线以及南北桥设计的硬件结构：

![image-20230804120218232](程序员的自我修养/image-20230804120218232.png)

## SMP和多核

SMP名为对称多处理器，每一个核在系统的地位和发挥功能一样，相互对称。适用于将一个大问题分解为若干个互不相干的子问题。这样能的大幅提升效率。

多核处理器和SMP之间是有细微差别的，因为多核处理器多个cpu核心之间是共享缓存等昂贵的部件，SMP则是独立的。一般来说，除非是很深入的优化（在缓存共享等方面由细微差别），否则可将SMP和多处理器看作一个概念。

## 系统软件

管理计算机本身的软件

平台性软件：操作系统内核，驱动程序，运行库，其他系统工具。（操作系统内核学习要开展！！！）

程序开发软件：编译器，汇编器，链接器，开发库等。（本书着重**连接器和开发库**，编译器和汇编器需要学习！！！）

**至理名言**：**计算机任何领域的问题都可以增加一个间接的中间层来解决**

![image-20230804164244004](程序员的自我修养/image-20230804164244004.png)



最上层使用运行库（提供应用程序编程接口）提供的接口来编写应用程序或者开发工具，运行库基于系统调用（内核）提供的接口来封装，以软件中断来使用系统调用。更进一步操作系统内核通过驱动程序来操作硬件。驱动程序通过硬件厂商提供的硬件规格（硬件接口）进行编写。

## os发展

 多道系统（无优先级，只能时序进行），分时系统（每个程序运行一会儿，没有优先级等，容易死循环（==无法被抢占==）等死机），**多任务系统**（进程概念的引出，优先级调度，很小的时间片，抢占式），**目前在使用的**。

## 设备驱动

驱动程序是操作系统的一部分，但它与操作系统之间有一定的独立性，==驱动程序通常由硬件生厂商来开发==。os屏蔽了底层的磁盘细节，物理扇区，磁道等，抽象出逻辑扇区。1）使用read系统调用读文件时。2）文件系统判断文件位于的逻辑扇区的区间。3）向硬盘驱动程序发送一个读取该逻辑扇区区间的请求，4）磁盘驱动程序收到请求后就向硬件发出硬件命令（最常见为读写I/O端口寄存器来实现向硬件发送IO命令，x86有65536个寄存器，不同硬件被分配到了不同的IO端口地址，CPU提供“in”/“out”实实现硬件端口的读写）。==IDE接口==

## 内存使用（内存不够）

1）**虚拟地址**的引出，地址空间的不隔离（程序破坏等）
2）内存使用率极低，运行多个程序时，内存不够，需要大量的换入换出到磁盘，拷贝花销大
3）程序运行地址不确定，每次装入时分配空间不一样，但是访问数据或指令跳转的目标地址基本是固定（物理地址这里不变）的，**涉及程序的重定位**

- 隔离性：虚拟地址和物理地址来实现
- 分段：操作系统设置映射函数，虚拟地址到物理地址的实际转换由硬件来做。可解决问题一和三，但是内存使用率还是不会变。==程序的局部性原理，只加载程序的一部分数据==
- 分页：虚拟地址空间的页叫做虚拟页（VP，物理地址空间的页叫做物理页（PP，磁盘中的页叫做磁盘页（DP。可对每个页设置权限，例如读写权限，以实现保护机制。MMU单元一般集成在CPU的内部，用于是实现虚拟地址到物理地址的转换。
  ![image-20230918145416775](程序员的自我修养.assets/image-20230918145416775.png)

## 线程初识
### 线程基础
- 线程即轻量级进程，程序执行的最小单元，标准线程组成：线程ID，当前指令指针（PC），寄存器集合和堆栈。同进程下的线程共享程序的内存空间（代码段，数据段，堆），其他进程级的资源（打开文件，信号），如图
![image-20230918150620846](程序员的自我修养.assets/image-20230918150620846.png)
- 多线程优点
1）某个操作陷入长时间等待，只能睡眠状态无法继续执行。多线程执行可有效利用等待时间执行其他线程
2）计算操作耗时，计算线程和用户交互线程可分离开，保证和用户交互不中断
3）程序逻辑要求并发操作
4）多核计算机，单线程无法发挥计算机的全部能力
5）对与多进程应用，多线程在数据共享方面的效率要高很多；原因是多线程可共享进程内的内存空间以及一些资源。进程内线程间通信效率要高于进程外通信效率。
- 线程访问权限
线程的私有存储空间
1）栈：一般无法被其他线程访问，除非有线程知道其堆栈地址
2）线程局部存储（TLS）：TLS是某些OS为线程单独提供的私有空间，容量有限
3）寄存器：寄存器是执行流的基本数据，线程私有
![image-20230918153148126](程序员的自我修养.assets/image-20230918153148126.png)
- 线程调度与优先级
1）运行状态和进程相似：就绪，运行，等待
2）线程优先级可以手动设置，如linux可以通过pthread库来设置。系统可根据线程的表现动态调整优先级；IO密集型的线程总比CPU密集型的线程更容易得到优先级的提升；避免线程被饿死，等待时间长则提升优先级
- 可抢占和不可抢占的线程，不可抢占线程中，线程调度时机只会发生在线程等待某些事件时，以及主动放弃时间片时
- Linux多线程
1）Windows中线程和进程的实现和教科书一样标准，Windows有明确API来产生进程和线程：CreateProcess/CreateThread。对linux而言，线程不是一个通用的概念。
2）Linux将所有的执行实体（线程或者进程等）都称作任务。Linux不同任务下可以选择共享内存空间，实际上来说共享同一内存空间的就是线程。Linux下创建新的任务
![image-20230918163003150](程序员的自我修养.assets/image-20230918163003150.png)
3）父任务的fork返回一个子任务ID，而新产生的子任务fork则返回0。==新fork任务和原任务共享一个可写时复制的内存空间，任意任务试图修改内存空间时，复制一份给修改方单独使用==
4）fork产生一个新的任务时，新任务可调用exec执行新的可执行文件；使用clone来产生新的线程

### 线程安全，多线程程序并发时数据的一致性问题
- 竞争与原子操作
线程不安全本质是因为多线程对同一个数进行操作，导致读写时的不一致性。为啥会出现这样的情况？本质是因为对这种共享数据的操作，例如i++，这种其实是会分解位很多条指令来执行，当很多线程同时对该数操作时，不同线程的指令执行是相互插入的，所以导致结果有不确定性，执行结果出错。如果系统提供了对这种加法的原子操作指令，即变为了原子指令，那么就不用担心结果的不确定性，只适用与简单场合
- 同步与锁
数据的访问同步，即只能有最多一个线程对数据进行访问，将数据访问原子化了
使用锁实现数据同步，锁是一种非强制的机制，分为获取锁和释放锁两步，下面为锁的实现
1）二元信号量，最简单的一种锁，两种状态（占用和非占用）
2）多元信号量，对允许多个线程并发访问资源适用，即常说的信号量机制
3）互斥量，和二元信号量相似，资源仅允许同时被一个线程访问，不同的是信号量可被任意线程捕获并释放，但互斥量则是哪个线程获取了互斥量就要负责释放这个锁
4）临界区，比互斥量更加严格，互斥量和信号量在系统是任何进程可见的，但是临界区的作用范围仅限于本进程，其他进程则无法获取该锁
5）读写锁，特定场合下的同步，读写锁能允许多个进程读取，读写锁有自由，共享，独占三种状态，如图：
![image-20230919095845926](程序员的自我修养.assets/image-20230919095845926.png)
6）条件变量，一种同步手段，线程可以等待条件变量以及唤醒条件变量。一个条件变量可以被多个线程等待。当该条件变量被唤醒（理解为等待某事件，事件发生了），所有等待该条件变量的线程都可以回复执行
- 可重入与线程安全
1）可重入函数：这个函数没被执行完成，由于外部因素或者内部调用，又一次进入该函数执行。可重入函数(多线程环境的线程安全)必须的特征：
![image-20230919105501464](程序员的自我修养.assets/image-20230919105501464.png)
- 过度优化，编译器技术存在很多自主优化的情况，这些自主优化可能会导致线程的不安全
1）编译器为提高变量访问速度，将变量放到了某个寄存器，==由于不同线程的寄存其是相互独立的，所以对变量加锁也不保证结果的正确性==
2）CPU的动态调度，执行程序为提高效率会交换指令顺序，故编译器在优化时，也可能为了效率而交换毫不相干的指令的执行顺序，从而导致代码的执行结果和我们预期的不一致
这个预期是r1,r2至少一个为1                                   实际上交换执行顺序后，r1,r2可能都为0              
![image-20230919112519152](程序员的自我修养.assets/image-20230919112519152.png)  ![image-20230919112606145](程序员的自我修养.assets/image-20230919112606145.png)
可以使用**volatile**关键字来阻止这个过度优化，其可以做到
![image-20230919113149303](程序员的自我修养.assets/image-20230919113149303.png)
使用该关键字可以解决寄存器缓存的问题，但是还是不能解决第二个指令乱序的问题，因为即使编译器这里停止调整顺序，但在CPU动态调度时，其还是可能执行换序的执行
另一个换序问题，单例模式（Singleton）中的double-check:
![image-20230919114809689](程序员的自我修养.assets/image-20230919114809689.png)
单例模式，一般允许这个线程只有一个类的实例，这个代码第一个if首先判断这个实例存不存在，不存在，再加锁，这样减少了锁的粒度；然后再进行if的判断，再产生一个新的实例。双重if可以将加锁的调用开销降到最低，加锁可以解决多线程竞争的麻烦。
**问题**
pInst=new T有三个步骤：分配内存->调用构造函数->将内存地址赋值给pInst。然而CPU是乱序执行的，意味着第二和第三步是乱序的。当第三步先执行时，如果另外的线程来对GetInstance（显然这是不可重入的函数）进行调用，那么PInst会返回一个确切的没有被初始构造的实例的地址给用户使用，可能会造成程序的崩溃（取决于具体的类的设计）。由此可见，CPU的乱序执行会极大的干扰我们的线程安全能力，所以需要一种可以阻止CPU换序的方法：
然而现在没有一种通用的可移植的阻止CPU换序的方法，通常可以调用CPU提供的barrier指令，可以阻止CPU将该指令前的指令交换到barrier之后。例如在POWERPC中的一条指令lwsync:
![image-20230919144548185](程序员的自我修养.assets/image-20230919144548185.png)
### 多线程内部情况
用户使用的时用户态的用户线程，然而用户态线程不一定对应操作系统内核里同等数量的内核线程。下面是三种线程模型：
#### 一对一模型
用户态的线程唯一对应一个内核使用的线程。然内核线程可能不存在与之对应的用户线程。
一对一模型的优点是可以做到用户线程和内核线程一致，故一个线程因为某些原因阻塞时，其他线程不会受到影响。一对一模型可让对多线程程序在多处理器系统上表现更好。
缺点：许多操作系统限制了内核线程的数量，故会使用户的线程数量受限。操作系统的内核线程调度时，上下文切换开销大，导致用户线程执行效率下降。
#### 多对一模型
多对一模型将多个线程映射到一个内核线程上。能提高用户的线程数量，相对减少内核线程的数量，从而减少内核的调度开销。
缺点：一个用户线程阻塞，那么所有与内核进程相关的用户线程均无法执行，因为内核线程阻塞了。
#### 多对多模型
将多个用户线程映射到少数，至少两个及以上的内核线程上。可以解决一对一模型中的对用户线程数量的限制以及多对一模型中的单点阻塞问题

# 第二部分 静态链接
## 第二章 编译和链接
通常IDE和编译器提供的默认配置，编译和链接参数对于大部分的应用程序开发已经够用，但是你只知道这些配置的参数，却不知道背后的原理，不知道它做了些什么，那又怎么根据性能瓶颈来选择对应的优化配置参数呢？
### 被隐藏的过程
gcc编译4步骤：预处理（预编译）->编译->汇编->链接；下面是具体的过程：
![image-20230920201413541](程序员的自我修养.assets/image-20230920201413541.png)
- 预编译
预编译的命令：
```shell
  gcc -E test_2chapter.cc -o test_2chapter.i
  #或者
  cpp test_2chapter.cc -o test_2chapter.i
```
==预编译过程中主要做的事==(主要处理以”#“开始的预编译指令，包括头文件，#define等)：
1）将所有"#define"删除，并且展开所有的宏
2）处理所有的条件编译指令。"#if","#endif","elif","else","ifdef"
3）处理"#include"预编译指令，将所有包含的文件插入到预编译指令的位置，递归的插入，因为头文件的递归包含
4）删除所有注释，"//"，"/* */"
5）添加行号以及文件标识，后面编译错误或警告显示行号（常见的情况）
6）保留所有的#pragma编译器指令，这个可以控制编译器的一些行为，例如优化控制，警告控制，链接控制等
==当我们无法判断宏定义正确或在头文件包含是否正确时，可查看预编译文件来解决这个问题==
- 编译
编译过程就是把预处理完的文件.i，进行一系列词法分析，语法分析，语义分析，优化后生成的相应的汇编代码文件.s,为程序构建的核心部分，等效的编译命令
```shell
gcc -S test_2chapter.i -o test_2chapter.s
```
也可以将预编译和编译整合到一起
```shell
gcc -S test_2chapter.cc  -o test_2chapter.s
```
不同的语言预编译和编译的程序不一样
|  编程语言      | 编译后台程序  | 
| ---- | ----|
| c语言| ccl|
| c++语言     |    cclplus | 
| OBjective-C     | cclobj|
|    fortran  |     f771 |      
|   Java| jcl|

==实际上来说gcc的命令是这些后台程序的包装，根据不同的参数去调用预编译编译程序ccl,汇编器as，链接器ld==
- 汇编
汇编器将汇编代码.s转换为机器可以执行的指令.o，汇编器的汇编过程相对于编译器来说比较简单，无复杂的语法/语义/指令优化，只能根据汇编指令和机器指令的对照表一一翻译
```shell
as test_2chapter.s -o test_2chapter.o
gcc  -C test test_2chapter.cc -o test_2chapter.o
gcc  -C test test_2chapter.cc -o test_2chapter.o
```
- 链接
为什么需要链接（因为使用了很多三方库？），为什么需要把这些库连接起来得到可执行文件？==本书重点==
### 编译器做了什么
如果没有编译器，我们只能使用汇编语言和机器语言来编写程序，但是值得注意的是，这样编写的程序是依赖与特定的硬件平台的，如果换了平台，程序就需要重新编写（显然不行）。所以编译器出现，我们可以尽可能少的考虑计算机本身硬件的影响，而尽可能多的关注程序的逻辑。编译过程一般有6步：扫描，语法分析，语义分析，源代码优化，代码生成，目标代码优化。
#### 扫描/词法分析
源代码程序输入到扫描器，进行词法分析，将源代码的字符运用类似有限状态机的算法将源代码的字符序列分割成一系列符号（token）。
这些token一般可以分为几类：
**关键字，标识符，字面量（数字，字符串），特殊符号（加号，等号等）**
扫描器在扫面分割字符的同时，同时将标识符存放到了符号表，将数字，字符串常量存放到文字表等
工具：lex程序可按用户描述好的词法规则对源代码进行字符串的分割。故编译器开发者只需要指定好既定的词法分割规则，而不用单独开发一个独立的词法扫描器。
==有预处理的语言，如C语言，其宏替换和文件包含等预处理工作一般是归入单独的预处理器，而不是交给编译器==
#### 语法分析
语法分析器对扫描器产生的token进行语法分析生成语法树，分析过程采用(上下文无关语法分析，下推自动机)。
![image-20230928145217297](程序员的自我修养.assets/image-20230928145217297.png)
如上图为语法树，其可以将表达式分解为一种树状表示。该语法树可以区分各种运算符的优先级，比如括号（）在乘号*前面，故其一般为（）的子节点；运算符的含义也确定了，例如星号*既可以是指针取内容也可以是乘法表达式，语法分析阶段就需要对这些内容进行区分，如果表达式不合法，各种括号不匹配，表达式中缺少操作符等，编译器就会报语法分析阶段的错误。
工具：语法分析有现成的工具yacc，可根据用户给定的语法规则对输入的记号序列进行解析，从而构建语法树。编程语言不同只需要改变语法规则，而无需为每一个编译器编写语法分析器（和编译器对硬件平台类似），故语法分析器又叫做"编译器编译器"。
#### 语义分析
语法分析只能完成对表达式的语法层面的分析，却不知道其真实的含义。编译器所能分析的语义是静态语义（编译可确定），动态语义则是在程序运行时才能确定的语义。
**静态语义**：类型的声明以及类型的匹配，类型的转换。
**动态语义**：动态语义在运行时的错误，比如将0作为除数是一个运行期语义的错误。
在语义分析阶段之后，语法树的表达式都表示了类型，有些类型需要做隐式转换，语义分析程序需在语法树中插入相应的转换节点。所以语义分析主要做的事是进行表达式含义的解析，并添加类型到语法树的各个节点中。并且还对符号表里的符号类型也做了更新。
#### 中间语言生成/源代码优化
源码级优化器，例如编译时可以确定的值，例如字符常量加法（2+6等），源代码优化器将语法树转换成中间代码，其一般与目标机器和运行时环境无关。中间代码类型：
三地址码，P-代码。
![image-20230928161239134](程序员的自我修养.assets/image-20230928161239134.png)
如图，转化为三地址码的形式，但是为了这种三地址码的表达方式，加入了许多的临时变量，源代码优化器可将2+6的值在编译时直接计算出来，那么就可以直接替换掉临时变量，减少变量。
中间代码的出现使编译器分为编译器前端以及编译器后端。（==这不就是LLVM的思想，或许LLVM就是借鉴的这种思想==）
编译器前端：负责产生机器无关的中间代码。
编译器后端：将中间代码转换成目标机器代码。
跨平台编译器可使用同一个编译器前端，以及针对不同机器平台的数个后端。
#### 目标代码生成和优化
编译器后端主要是：代码生成器，目标代码优化器。
代码生成器：代码生成器主要将中间代码转化为目标机器代码。依赖于目标机器（不同字长，寄存器，整数数据类型，浮点数数据类型等）。代码生成器将中间代码转换成下面的代码序列：
![image-20230928164033209](程序员的自我修养.assets/image-20230928164033209.png)
目标代码优化器可以对上述的目标代码进行优化，选择合适的寻址方式，使用位移代替乘法运算，删除多余的指令。上述图片的乘法就可以使用基址比例变址寻址的lea指令来完成，然后使用mov完成赋值操作。
现代编译器有着异常复杂的结构，由于现代高级编程语言的复杂性以及CPU的复杂性（流水线，多发射，超标量等诸多复杂特性），所以编译器的机器指令优化非常复杂。为了在编译过程中支持多
多种硬件平台，允许编译器编译出多种目标CPU的代码。
经过这些编译步骤后：变量的地址其实还没有确定，如何得到变量的地址，如果变量定义在同一个编译单元里，编译器可以为index，array分配空间，确定地址，如果是在其他的模块呢，事实上，定义在其他模块的全局变量以及函数的最终运行的绝对地址需要在最终链接时才能最终确定。现代编译器将源代码文件（即变量，函数的定义）编译为一个未链接目标文件（静态库.a/动态库.so）。
### 链接器年龄比编译器长
打孔年代，用地址标识指令，但是如果目标指令地址发生变换，则对应的打的孔要对应发生变换，重新计算目标地址的过程被叫做重定位。这种方式繁琐，所以后面出现了汇编语言，用符号来标识目标(变量，函数)地址，这样极大的解放生产力，方便进行重新开发。汇编语言的出现逐渐带来了程序的膨胀（生产力爆棚），程序膨胀带来程序的模块化，模块间的变量的相互如何引用，引出来链接的主题：
![image-20230928175817367](程序员的自我修养.assets/image-20230928175817367.png)
### 模块拼装-静态链接
复杂软件需要分割为独立的小模块进行独立编译，再"组装"起来，即链接过程。包括了地址和空间分配，符号决议，重定位等。
对于符号决议：
![image-20231007092708566](程序员的自我修养.assets/image-20231007092708566.png)
现代编译链接过程：在模块A中使用模块B中的函数foo()，在编译模块A时，由于模块独立编译，不知道这个函数的入口地址；所以暂时将调用foo()函数的指令的目标地址搁置，等待链接器将模块A，B链接起来时，模块A再根据符号foo来自动查找foo()函数的地址。
对：
![image-20231007094621139](程序员的自我修养.assets/image-20231007094621139.png)
这是在目标文件B里面使用目标文件A的全局变量var，在编译目标文件B时，编译器不知道变量var的目标地址，故首先将目标地址即var的地址置为0，再在链接目标文件A，B时来修正。如果变量var的地址确定为0x10000，链接器就会修改指令目标地址为0x10000，这个过程叫做重定位。
### 本章小结

## 第三章 目标文件里有什么
目标文件即为编译器经过源代码生成的文件，目标文件从结构上来说它是已经编译后的可执行文件的格式，只是没有经过链接的过程，有些符号或者地址还没有经过重定位进行调整，但其本身是按照可执行文件格式来存储的。
### 目标文件格式
PC平台流行的可执行文件格式，Windows下的PE（Portable Executable）和Linux的ELF(Executable Linkable Format)，都为COFF(Common file format)格式变种。
可执行文件，目标文件，windows和Linux下的静态库和动态库都是按照可执行文件格式（PE-COFF，ELF）来存储的。
ELF文件格式有4种：
![image-20231007102629412](程序员的自我修养.assets/image-20231007102629412.png)
![image-20231007102644879](程序员的自我修养.assets/image-20231007102644879.png)
==我们可以根据这个图得到哪些文件可以连接然后生成哪些文件==
COFF由Unix System V Release 3提出的格式规范，微软再基于COFF格式，指定了PE标准。System V Realease 4在COFF基础上引入了ELF格式。COFF格式的主要贡献是在目标文件里引入了"段"机制。
ELF文件主要有三个重要索引表：
- ELF header：文件开始，描述整个文件的组织。
- Program header table：告诉系统如何创建进程映像，构建进程映像的目标文件必须有程序头部表，可重定位文件不需要。
- Section header table:包含描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称，节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他则是可有可无。
- sections/segments：segments从运行的角度来描述elf文件，sections则是从链接的角度来描述elf文件。通常一个segment包含了多个section。
![image-20231007110848808](程序员的自我修养.assets/image-20231007110848808.png)
### 目标文件是什么样的
程序编译后额机器指令被放在代码段里，常见的是".code"/".text"，全局变量和局部静态变量被放在数据段，一般为".data"。
ELF的文件头描述整个文件属性：文件是否可执行，静态链接/动态链接，入口地址（对于可执行文件）,目标硬件，目标操作系统等。
对于c语言来说，其编译后的执行语句都编译成机器代码，保存在".text"段，已初始化的全局变量和局部静态变量在“.data”段，未初始化的全局变量和局部静态变量一般在".bss"段。==可执行文件必须记录未初始化的全局变量以及局部静态变量的大小总和==，记作.bss段
为什么程序的数据和指令需要分开？即分开的好处：
- 程序装载后，数据和指令映射的虚存区域不同，数据区是可读写的，但代码区是只读的。==权限细分==
- 现代CPU的缓存机制，将数据和指令分离可以提高程序的局部性，且现代CPU的指令缓存和数据缓存是分离的，故程序的指令和数据被分开存放有利于提高缓存命中率。
- 运行多个程序副本时，指令一样，只是数据不一样（类比为现代操作系统只用加载一份动态库到内存中，可以理解为只需要一份就可，不同进程只是数据不一样，动态库指令一样）。 
### 挖掘SimpleSection.o
首先编译文件得到目标文件SimpleSection.o，使用binutils的工具objdump工具查看目标文件内部结构
![image-20231007141625723](程序员的自我修养.assets/image-20231007141625723.png)
其中".rodata"为只读数据段，用于存储常量或者静态不修改字符串等其他只读数据，".comment"为注释信息段，用于存储版本信息，编译器信息等：
![image-20231007143711267](程序员的自我修养.assets/image-20231007143711267.png)
，".note.GNU-stack"为堆栈提示段，指示栈能否执行等。"eh_frame"段包含异常处理框架信息，支持程序的异常处理以及堆栈跟踪等。
下面时该目标文件个段的基本分布：
![image-20231007144059611](程序员的自我修养.assets/image-20231007144059611.png)
size命令查看目标文件的各段的大小：
![image-20231007142449975](程序员的自我修养.assets/image-20231007142449975.png)
#### 代码段
使用objdump -s -d来查看代码段的具体内容，-s将段内容以十六进制方式打印出来，-d可包含指令的段反汇编
![image-20231007153028966](程序员的自我修养.assets/image-20231007153028966.png)
#### 数据段和只读数据段
.data只保存全局静态变量以及局部静态静态变量，一般来说字符串常量存储在只读数据段.rodata。.rodata段存放只读数据，如程序的只读变量（const变量）和字符串常量。'.rodata'段不光在语义上支持C++的const关键字，操作系统加载时可将".rodata"映射为只读；可搭配只读存储器例如ROM使用，保证程序的安全性。
有时候编译器会把字符串常量放到".data"段，而不是放在".rodata"段（==取决于编译器，以及编译选项吗？==）
此外不同编译器还涉及到变量存放的字节序问题，即大小端问题。
#### bss段
".bss"段一般存放的是未初始化的全局变量以及局部静态变量。对于SimpleSection.c文件中，global_uninit_var和static_var2而言一个被存放在bss段，由size命令可以看到其为8，对于书上的bss段只有4字节，因为global_uninit_var没有被放在任何段，只是未定义的“COMMON”服符号；==这和语言以及编译器是高度相关的==，一些不存放在bss段，而是预留未定义的全局变量符号，在最终的链接成可执行文件时再在bss分配空间，一般加上static修饰的内部可见的未初始化静态变量时存放在bss段的。
对于下图：
![image-20231007160747594](程序员的自我修养.assets/image-20231007160747594.png)
x1放在bss段中，x2放在data段中，因为x1虽然赋值初始化了，但其实赋值为0，编译器会直接优化掉，因为未初始化的都为0.
#### 其他段
ELF文件除了.text/.data/.bss这三个最常用段外，还有：
![image-20231007161606442](程序员的自我修养.assets/image-20231007161606442.png)
除了这些加"."的前缀是系统保留的以外，应用程序可以使用一些非系统保留的文字作为段名，如在ELF文件中插入“music”段，存放一首mp3的音乐，elf文件运行时可以读取该段并且播放这首MP3,自定义段的段名最好不加前缀"."，避免和系统的段冲突。一个elf文件可以有几个相同段名的段。
==objcopy工具的使用==：
该工具可以完成一种目标文件格式到另一种目标文件转换，即可以将图片/MP3音乐/词典之类的东西转换成目标文件的一个段等。
#### 自定义段
一般来将，具体的变量函数存放的段是固定的。但为了一些特定功能，如满足硬件内存/IO的地址布局或者像Linux内核里面完成一些初始化和用户空间复制时出现页错误异常。gcc提供一个扩展机制，使程序员可指定变量所处的段：
![image-20231007170144841](程序员的自我修养.assets/image-20231007170144841.png)
### ELF文件结构描述
包含了ELF文件头，段表，各段信息，符号表/字符表；节表，节信息等
#### 文件头
使用readelf来解析目标文件的文件头：
![image-20231007171134980](程序员的自我修养.assets/image-20231007171134980.png)
elf文件头结构及相关常数定义在“/usr/include/elf.h”中,里面定义了很多的数据结构；这些数据结构和elf头部文件的文件结构相对应。如：
![image-20231007175635950](程序员的自我修养.assets/image-20231007175635950.png)
###### ELF魔数，最前面的“Magic”16个字节对应数据结构中的e_ident成员。
a.out格式最开始的两个字节为0x01，0x07；PE/COFF文件最开始两个字节为0x4d，0x5a。可以用魔数来确定文件的类型，在加载可执行文件时会确认魔数是否正确，正确才会加载。
==魔数的由来==
为什么a.out格式的魔数时0x01,0x07；故事是：UNIX在PDP小型机上产生，在文件开始放入跳转指令，负责跳过接下来的7个机器字的文件头到可执行文件的真正入口。0x01和0x07正好是PDP跳转7个机器字的指令。==核心其实是为了保持和以前系统的兼容性==，所以一直保留到今天。==类似著名的 马屁股和航天飞机的故事==.
##### 文件类型
e_type标识文件类型，一般有三种文件类型：
![image-20231007195205885](程序员的自我修养.assets/image-20231007195205885.png)
##### 机器类型
ELF格式可以在多种平台使用，同一ELF文件不可在不同的平台下使用，只是遵循一个ELF标准。e_machine不同的值：
![image-20231007195644659](程序员的自我修养.assets/image-20231007195644659.png)
#### 段表
段表是保存目标文件中段基本属性的结构（段名，段的长度，文件中的偏移，读写权限等）；编译器/链接器/装载器是靠段表来定位和访问各个段的属性。如图：
![image-20231007200455180](程序员的自我修养.assets/image-20231007200455180.png)
共有13个段，首段为NULL,故有效段为12个。这个其实就是该目标文件的段表，每一项描述一个段，描述段的结构体称为段描述符，定义在elf.h文件中。段表的大小为段的个数*sizeof(段描述子)
##### 段的类型
段的名字只在编译和链接过程中有意义，并不是真的段的类型。段的属性主要由段的类型和段的标志位决定。如图段的类型
![image-20231007202121907](程序员的自我修养.assets/image-20231007202121907.png)
![image-20231007202130892](程序员的自我修养.assets/image-20231007202130892.png)
##### 段的标志位
标志位只表示该段在进程虚拟地址空间的属性，例如：可写？/可执行?等。如图：
![image-20231007202346360](程序员的自我修养.assets/image-20231007202346360.png)
对系统保留段，段类型和段的标志位表：
![image-20231007202717074](程序员的自我修养.assets/image-20231007202717074.png)
![image-20231007202724394](程序员的自我修养.assets/image-20231007202724394.png)
##### 段的链接信息
如段的类型和链接相关，例如重定位表，符号表等。其他类型段这两项无意义。
![image-20231007205346373](程序员的自我修养.assets/image-20231007205346373.png)
#### 重定位表
链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段对绝对地址引用的位置；每一个需要重定位的代码段和数据段都需要一个重定位表，每一个重定位表同时是elf文件的一个段。
#### 字符串表
elf文件中用到了很多字符串。其存储方式是将字符串以单个字符的形式集中起来放到一个表，使用字符串表中的偏移来引用字符串。如：
![image-20231008092700402](程序员的自我修养.assets/image-20231008092700402.png)
![image-20231008092713278](程序员的自我修养.assets/image-20231008092713278.png)
通常有两个字符串表，一个是字符串表（用于elf文保存普通的字符串，如符号）；一个是段表字符串（用来保存段表中用到的字符串，例如段名）
### 链接的接口-符号
在链接中，统一将函数和变量称为符号，函数名与变量名叫做符号名。每个目标文件都有一个相应的符号表，每个定义的符号都有一个符号值；一般对变量或者函数来说，其值就是指其地址。符号表中符号分类：
- 定义在本目标文件的全局符号，可以被其他目标文件引用
- 本目标文件引用了全局符号，但是没有定义在本目标文件，一般叫做外部符号，即符号引用
- 段名，符号由编译器产生，值即为该段的起始地址
- 局部符号，编译单元内部可见，如"static_var"等定义的局部静态变量。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件
- 行号信息，目标文件指令和源代码代码行的对应关系
==一般在链接过程中，只关注第一二类符号；其他只是局部可见的==
使用readelf，objdump，nm可查看elf文件的符号表：
![image-20231008100332702](程序员的自我修养.assets/image-20231008100332702.png)
#### elf符号表结构
符号表通常也是文件中的一个段，一个符号项是有一个elf文件的对应的数据结构来表示。
**符号类型与绑定信息**：
![image-20231008102152853](程序员的自我修养.assets/image-20231008102152853.png)
![image-20231008102200821](程序员的自我修养.assets/image-20231008102200821.png)
**符号所在段**：定义在本目标文件中，则表示符号所在段在段表中下标。如符号不是定义在本文件中：
![image-20231008102539527](程序员的自我修养.assets/image-20231008102539527.png)
**符号值**：三种情况
- 目标文件中，如果该符号定义了且不是”COMMON“块的（例如main，funcl等），其表示在段中（由符号所在段st_shndx给出）的偏移
- 在目标文件中，符号是”COMMON块“类型的，则符号值表示其对齐属性
- 可执行文件中，符号值表示符号的虚拟地址
![image-20231008103748470](程序员的自我修养.assets/image-20231008103748470.png)
如上图，这是和符号表项相对应的输出格式。
#### 特殊符号
ld作为链接器在链接生成可执行文件时，会产生很多特殊的符号，如：
![image-20231008110733004](程序员的自我修养.assets/image-20231008110733004.png)
这些符号是可以直接在编写代码时直接引用的
#### 符号修饰与函数签名
目标文件编写的函数或变量如果和要使用的库里的重名会产生冲突，于是可以加上符号修饰；一般c语言源代码文件在编译后，所有全局变量或者函数的符号名前都会加上下划线”_“；而Fortran语言是前后都加上下划线"_"。但是如果同一语言编写的多个目标文件有符号吃冲突时，怎样做？所以后面c++这样后来设计的语言加上了命名空间来规避。不同编译器有不同行为，可能会加上下划线也可能不加现在；可以手动设置编译参数来决定是否符号前加上下划线。
**c++符号修饰**：函数签名包括了函数的信息（参数类型，所在类，命名空间等），在编译器和链接器处理符号（这里是函数名）时，使每个函数签名对应一个==修饰后名称==。编译器在将源代码编译成目标文件时，会将函数和变量一起修饰，形成**符号名**。所以相同函数名的函数由于函数签名的不同，所生成的目标文件的对应的函数的符号名其实是不同的。如图：
![image-20231008154149000](程序员的自我修养.assets/image-20231008154149000.png)
![image-20231008154206088](程序员的自我修养.assets/image-20231008154206088.png)
在编译器进行修饰后，6个函数签名对应的最终的符号名：
![image-20231008154220555](程序员的自我修养.assets/image-20231008154220555.png)
至于gcc编译器对待函数签名的修饰标准，==er。后面看编译器再看==
对于变量来说，其名字修饰机制里没有加上其参数类型，所以对待一个变量，无论其实浮点型，整型，还是一个全局对象，其最终的符号名是一样的；==是否导致了gcc编译器不能有同名的变量声明在同一个作用域里面？多重定义的问题由来==
**需要注意的是**：不同的编译器一般名字修饰机制是不一样的。
==不同编译器一般采用不同的名字修饰方法，所以不同编译器产生的目标文件无法相互链接==。
#### extern "C"
C++编译器会将extern ”C“内部的代码当作C代码进行处理。
如下图实验：
![image-20231008162440789](程序员的自我修养.assets/image-20231008162440789.png)
![image-20231008162454649](程序员的自我修养.assets/image-20231008162454649.png)
提前根据名字修饰规知道变量var的修饰后符号名，直接用符号名引用变量值成功。
如果c/c++语言都包含了一个C语言的库函数的一个函数，例如string.h中的memset函数。
对C语言编写的，其可以将memset函数修饰为可以识别的符号名和库进行链接。但对于C++语言，需要使用extern "C"来处理这个函数，避免其按照C++的名字修饰规则生成符号名，导致不能和C库的相应函数链接。那么怎样在不写两套代码的情况下处理这种情况，如图：
![image-20231008164732332](程序员的自我修养.assets/image-20231008164732332.png)
==__cplusplus宏可以用于判断当前的C++语言的标准以及判断代码是否是C++代码==
#### 弱符号和强符号
符号多重定义，多个目标文件含有相同名字的==全局==符号会出现该错误。编译器默认函数和初始化的全局变量为强符号，未初始化的全局变量为弱符号。
![image-20231009092000916](程序员的自我修养.assets/image-20231009092000916.png)
其中，strong，main皆为强符号；weak，weak2皆为弱符号。ext为外部引用，两者都不是。
链接器按照下面规则选择被多次定义的全局符号：
- 如果在不同目标文件中，有多个同名强符号定义，链接器会报符号重定义错误。
- 如果一个符号为强符号，其他为弱符号，则选择强符号。
- 如果都为弱符号，选取占用空间最大的一个。）应该尽量避免这种情况。
**弱引用和强引用**：目标文件到可执行文件，对外部目标文件的符号引用需要被正确决议。找不到符号定义会符号未定义出错。处理弱引用时，符号有定义，链接器对符号的引用决议；如果未定义，链接器对引用不报错。弱引用和弱符号用于库的链接，弱符号和COMMON块联系紧密。
gcc里可使用 ”__attribute__((weakref))“来声明外部函数的引用为弱引用，未初始化的话，链接器默认值为0.
弱符号和弱引用作用很大。一是库里的弱符号可以被用户定义的强符号覆盖；二是程序对扩展模块的引用定义为弱引用，当扩展模块和程序链接在一起时，功能模块可正常使用，去掉某些功能模块，也可正常链接。==裁剪组合更加方便==
### 调试信息
目标文件可能也保存调试信息，编译器需要知道源代码和目标代码间的关系。gcc加上“-g”，编译器会在目标文件里产生调试信息。readelf查看。ELF文件采用一个DWARF的标准调试信息格式。==调试信息通常在目标文件和可执行文件中有较大比重，在开发完程序需要发布时需要去掉这些调试信息==
## 第四章 静态链接
### 空间地址分配
链接器如何将各个段的输出合并到输出文件/输出文件空间如何分配给输入文件。
#### 按序叠加
即多个目标文件的代码段，数据段，bss段等依次叠加；如果输入文件很多，造成最终的可执行文件有大量段存在，浪费存储空间，如果是x86的分页机制，可能有大量内存碎片，因为一个段至少一个页。
#### 相似段合并
代码段和代码段合并，bss段和bss段合并等。对待代码段和数据段，链接器需要在可执行文件以及虚拟地址空间中都分配空间；对于bss段来说，分配空间仅限于虚拟地址空间在文件中没有内容。
**两步链接法**：
- 空间与地址分配：扫面所有输入文件，收集各个段的长度，属性，位置，合并这些段，重新建立映射（建立段表？）收集每个输入文件的符号表，统一放到全局符号表。
- 符号解析与重定位：读取输入文件中的段数据，重定位信息，进行符号解析与重定位，调整代码中的地址。
链接后的地址是进程中的虚拟地址，即VMA。链接前VMA是0,因为还未分配，默认为0.链接后就可以分配虚拟地址。值得注意的是为什么其分配的虚拟地址不是从0开始分配的?
这是和操作系统的进程虚拟地址空间分配规则有关的。Linux下，elf可执行文件默认从0x08048000开始分配。
#### 符号地址的确定
在前面分配空间完成后，需要计算各个符号的虚拟地址，其实就是计算各个符号在段内的偏移量X，因为段的起始地址是确定的.只需要起始地址加上X就可以得到最终符号的地址。这样计算完成后再更新全局符号表，得到符号最终的地址。
### 符号解析与重定位
#### 重定位
对于未初始化的变量和函数来说，在位链接前，目标文件中的变量地址以及函数偏移量暂时以某些值来代替；在链接后，变量地址，以及函数的偏移量就确定了；如图：
重定位前：
![image-20231009113820665](程序员的自我修养.assets/image-20231009113820665.png)
重定位后：
![image-20231009113840599](程序员的自我修养.assets/image-20231009113840599.png)
#### 重定位表
一个重定位表往往就是一个elf文件中的一个段。每个需要被重定位的地方叫做重定位入口，入口偏移是相对于入口在需要被重定位的段中的位置。
在Intel x86的32位处理器中，重定位表对应一个数组，每个数组元素都是一个重定位入口：
![image-20231009115614866](程序员的自我修养.assets/image-20231009115614866.png)

#### 符号解析
在链接器对某个符号的引用进行重定位时，需要确定符号的目标地址。这是去查看全局符号表，找到对应符号在进行重定位。在链接器扫描完所有目标文件后，这些未定义的全局符号必须能在全局符号表中找到，否则未定义错误。
#### 指令修正方式
寻址方式：
近址/远址；绝对/相对；寻址长度（8位，16，32，64）。32位x86有两种指令寻址方式：绝对近址32位寻址/相对近址32位寻址
![image-20231009143751544](程序员的自我修养.assets/image-20231009143751544.png)
![image-20231009143840429](程序员的自我修养.assets/image-20231009143840429.png)
### COMMON块
多个符号同名但类型不一致的情况：
- 两个及以上强符号类型不一致
- 一个强符号，其他弱符号，类型不一致
- 两个及以上弱符号类型不一致
第一种情况非法，后面两种情况再分析：
编译器和链接器都支持COMMON块的机制，==不同目标文件的COMMON块空间大小不一致，以最大一块为准==。
COMMON类型链接规则是针对弱符号，如果出现强符号，最终的输出文件中符号所占空间和强符号相同。
问题：==为什么未初始化全局变量和未初始化的局部静态变量不一样，前者在COMMON块，后者在BSS段？==
正是由于COMMON块的变量在编译时无法确定其真正的大小，所以无法为其在BSS段分配空间；但是在链接器链接过程中可以确定弱符号大小，可在最终的输出目标文件中为其在BSS段分配空间。
==这里有一个多个文件出现同一个变量的多个定义（粗心忘记使用extern），为解决这个问题。编译器和链接器直接把未初始化全局变量都当作COMMON类型处理==
可使用gcc的"-fno-common"或者'__attribute'扩展·来将所有未初始化全局变量不用COMMON块形式处理。此时的符号就变成了一个强符号，冲突则会报错。
### C++相关问题
C++的==重复代码消除以及全局构造与析构==需要编译器和链接器共同支持才能完成工作。
C++的各种特性，如虚拟函数，函数重载，继承，异常等，使数据结构异常复杂。编译器和链接器间不能通用，导致C++程序的二进制兼容是个问题。
#### 重复代码消除
C++编译器很多时候会产生重复的代码，如模板，外部内联函数，虚函数表；可能在不同目标文件生成重复的代码。
一个有效做法：将每个模板的实例代码都单独放在一个段，每个段只有一个模板实例。
对模板来说，不同的参数类型实例化的模板都保存在不同的段中；这是不同目标文件的相同参数类型实例化的模板，其模板函数修饰后名称一样，在链接器链接时只需要选择一个进行链接，这样解决了多目标文件模板实例重复代码的问题。对于外部内联函数以及虚函数表也是如此。
==这种方法虽能基本解决代码重复问题，但是如果不同的编译单元，即目标文件使用的编译选项或者编译器版本不一致==，这是链接器对待相同名称的段还是会随机选择一个段作为链接输入，同时有警告信息。
##### 函数级别链接
程序和目标文件异常大，一个目标文件可能有成千上百函数，变量。如果只用到其中一部分，但是却需要连接整个，太庞大了；所以可以使用函数级别链接。
其可以让目标文件所有函数单独保存为一个段，像前面的模板函数一样。链接器需要一些函数时就可以链接进去，不需要就丢弃。可以减少输出文件的长度。
visual c++以及Gcc（-ffunction-sections,-fdata-sections）都可以有编译选项来实现函数级别链接。缺点是，这会减慢编译和链接过程，目标函数段数量增加，重定位变得更加复杂。
#### 全局构造与析构
c/c++程序在main函数调用之前，为了程序顺利执行，需初始化进程执行环境，如堆分配初始化，线程子系统；C++的全局对象构造函数执行；析构函数在main函数之后被执行。
Linux系统一般程序的入口时"_start"，该函数是程序初始化部分的入口。在main之后，再返回初始化部分，进行一些清理工作，再结束进程。
elf文件中有两个特殊的段：
- .init，保存可执行指令，构成的初始化代码，main函数被调用前，Glibc初始化部分安排执行该代码
- .fini，保存进程终止指令，当main函数正常退出，Glibc安排执行这段代码
#### C++与ABI
==每个编译器都能编译出目标文件，那么不同编译器编译出来的目标文件能否相互链接？==   和二进制兼容性有关
我们把符号修饰标准，变量内存布局，函数调用方式与可执行二进制兼容性有关的叫做ABI
影响ABI的因素非常多，硬件，编程语言，编译器，链接器，操作系统等。决定目标文件是否二进制兼容：
内置类型（float，int等；以及存储器中的存储方式，大小端对齐方式），组合类型（struct，union，数组等的存储方式和内存分布），外部符号
（即符号修饰标准，以及是否加下划线等），函数调用方式（参数入栈顺序，返回值保持），堆栈的分布方式（参数的堆栈位置，参数传递方法等），寄存器使用约定（函数调用哪些可修改，哪些可保存）
c++时代，语言层面更加深了二进制兼容下的问题：
继承类体系的内存分布，虚函数调用，模板的实例化，外部符号修饰，全局对象析构/构造，RTTI的实现等
C++的二进制兼容性一直被人诟病，需要统一的C++ABI标准，但是GNU的gcc体系以及VISUAL c++两大体系互不兼容，问题长期存在。
### 静态库链接
一个静态库是一组目标文件的集合，很多目标文件压缩打包后形成一个文件。
对于c语言的运行库（glibc），包含了输入输出，文件操作，时间日期，内存管理等系统功能，glibc由成千上万源代码文件组成，编译也会生成相应数量文件，需要使用"ar"将这些功能.o文件压缩到一起，形成libc.a。
![image-20231010160219538](程序员的自我修养.assets/image-20231010160219538.png)
查看静态库的目标文件信息。
下面使用objdump -t查看libc.a
![image-20231010161619439](程序员的自我修养.assets/image-20231010161619439.png)
gcc编译参数"-fno-builtin"可以避免编译器进行自我优化，将只使用一个字符串参数的"printf"替换为"puts"。
ldd可以寻找自己所需的符号和所在的目标文件.
静态库链接的具体过程：
![image-20231010162829744](程序员的自我修养.assets/image-20231010162829744.png)
静态链接会将静态库中一些目标文件和编写的目标文件链接生成最终的可执行文件，可执行文件只需要链接用到的.o，而不是整个静态库的文件。==注意和动态链接的区别==
### 链接过程控制
大部分情况，链接器按照默认链接规则对目标文件进行链接，对一些特殊的程序，如内核，BIOS或其他嵌入式系统的程序等，一些内核驱动程序有受限的特殊条件：输出文件各个段虚拟地址，段的名称，段存放的顺序等对程序的各个段的地址有特殊要求。
#### 链接控制脚本
链接器控制整个链接过程有三种方法：
- s使用命令行给链接器指定参数。
- 链接指令放在目标文件，编译器可通过这种方法向链接器传递指令。
- 使用链接控制脚本。
ld会根据命令行的要求使用相应的链接脚本来控制链接过程；一般不同的机器平台以及输出文件格式有相应的链接脚本，也可自定义一个脚本为链接控制脚本
#### 最"小"程序
使用内嵌汇编，可避免使用了c运行库，不用使用main函数。
![image-20231010175503783](程序员的自我修养.assets/image-20231010175503783.png)
![image-20231010175621867](程序员的自我修养.assets/image-20231010175621867.png)
这边使用编译和链接命令来生成可执行文件，不用main函数原理是其实是更改elf文件的入口地址，elf文件头定义。。
#### 使用ld链接脚本
```c
ENTRY(nnomain)
SECTIONS{
    .=0x08048000+SIZEOF_HEADERS;
    tinytext : {*(.text) *(.data) *(.rodata)}
    /DISCARD/：{*(.comment)}
}
//设置函数进入点为nomian
//设置tinytext段开始的地址为=0x08048000+SIZEOF_HEADERS，SIZEOF_HEADERS为elf文件头的大小
//tinytext将后面三个段一次合并
//discard为丢弃后面的段
```
#### ld链接脚本语法简洁
ld链接脚本语法类似于c语言，下面是链接脚本语法中的个命令语句说明：
![image-20231011144449559](程序员的自我修养.assets/image-20231011144449559.png)
![image-20231011144500387](程序员的自我修养.assets/image-20231011144500387.png)
除此之外，还有很多命令语句格式，最重要和复杂的是SECTIONS命令。冒号后面的为contents，筛选满足条件的段。
![image-20231011150024201](程序员的自我修养.assets/image-20231011150024201.png)
### BFD库
不同的软硬件平台有着不同的目标文件格式，即使是同一格式也可能有差异。这样导致编译器，链接器很难处理不同平台的目标文件。这是需要一个统一接口可以对不同格式进行处理。
BFD库是一个GNU项目，希望用一种统一接口来处理不同的目标文件格式。其本身是binutils项目的一个子项目。现代Gcc（GNU中的汇编器，编译器等），链接器ld,调试器gdb，以及binutils中其他工具通过BFD库来处理目标文件，而不是直接操作目标文件。BFD开发库需要安装以使用。
## 第五章 Windows PE/COFF （ 简略看
### 链接指示信息
“.drevtve”段内容是编译器传递给链接器的指令，即编译器希望告诉链接器怎样链接这个目标文件。
总结：Windows下的可执行文件，动态链接等都使用PE文件格式。
# 第三部分 装载与动态链接
## 第六章 可执行文件的装载与进程
可执行文件只有装载到内存后才能被CPU执行，硬件MMU的产生，多进程，多用户，虚拟存储的操作系统出现后，可执行文件装载变得很复杂。
### 进程虚拟地址空间
cpu的位数决定虚拟地址空间的大小。硬件的寻址空间大小决定了最终的地址空间的理论上线。
我们可以通过c语言程序的指针的所占空间来计算虚拟地址空间大小；一般的，c语言指针大小和虚拟地址空间大小相同。
进程的虚拟空间是在操作系统的掌握中的，进程只能使用os分配给进程的地址，如果访问地址未经允许，那么操作系统捕获到这些访问后，会将这种访问当作非法操作。
对于虚拟地址空间的分配，其中1GB给内核态的用户空间，3GB给用户态的用户空间。原则上说，进程只能使用3GB的分配的虚拟空间，超过了的话只能换64位或者是使用“PAE”技术。
可以修改内核用户空间和用户的虚拟地址占比。1：3；2：2等
#### PAE技术
32位CPU下，虚拟地址空间大小只有4GB,但是对于物理地址来说，如1995年开始，奔腾Pro CPU开始采用36位的物理地址，可访问64GB的物理内存。
Intel通过修改页映射方式，使进程能访问到更多的物理内存。Intel把这个地址扩展方式叫做PAE.
应用程序如何使用这些超出的内存空间?对待应用程序中的正常大小的256GB虚拟地址空间用作窗口，应用程序可从物理地址超出4GB的部分，，申请多个不同过的物理块，大小为256GB。Windows下这种操作方式叫做AWE.Linux等类UNIX系统使用mmap来实现。
### 装载的方式
静态装入：将程序允许所需的指令和数据全部装入内存。
==动态装入==：程序运行的局部性原理，将不常用的数据放在磁盘，最常用部分放在内存。
动态装载常用方法：覆盖装入/页映射。利用程序的局部性原理。程序用到那个模块，再将那个模块装入内存，不用则暂时存在磁盘中。
#### 覆盖装入
覆盖装入将程序分为若干个块，编写一个小的辅助代码（覆盖管理器）来管理模块在内存中的驻留以及何时应该被替换掉。这样需要整理程序各个模块的调用依赖关系为树状结构来决定覆盖关系。
![image-20231011172531989](程序员的自我修养.assets/image-20231011172531989.png)
- 树状结构到从任意模块到根叫做调用路径。一个模块调用时，其调用路径上所有模块应该都在内存。
- 禁止跨树间调用，即A不可以和B，E，F等，当跨树间的模块依赖同一个模块H时，需要将该模块保存到main模块。
==显然这种以覆盖管理器的方式来决定程序的段的装载形式，是一种典型的用时间换取空间（能加载更多块）的方法==。
#### 页映射
页映射本身是虚拟存储机制的一部分。将内存和磁盘的数据和指令按照页来进行划分，故装载和操作的单位就为页。一般页大小为4KB.
将虚拟空间和物理空间都划分为页，当内存满是，需要使用FIFO,LRU等页替换算法来将该页替换近内存。这个装载过程是os的存储管理器在管。==目前几乎所有主流操作系统都使用这种方式来装载可执行文件，Windows的PE文件装载以及ELF文件装载都使用这样的方式==
### 从os角度看可执行文件的装载
