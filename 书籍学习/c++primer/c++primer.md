# 大致规划:
<!-- 2023.9.13-9.14 第一部分
2023.9.15-9.17 第二部分
9.17-9.24 第三部分加上c++11新特性 -->
后面的第四部分可以选择性学习过一遍。
# c++基础，第一部分
## c++简介部分
学！！！！！！
## 变量和基本类型
- 尽量使用double进行浮点运算，算数表达式中不轻易使用char或者bool进行计算，因为char在不同体系结构可能有不同的取值范围，有些是signed，有一些则是unsigned的。同一个表达式，有signed和unsigned，那么signed会被当做unsigned进行计算。
- 变量初始化，有些类需要显示初始化，最好能初始化就初始化.变量可以extern多次声明，一次定义。
- ==实验1：对指针和引用的使用进行小实验，引用初始化指向指针（int *&p=q/int &p=*q），和指针指向引用变量(int *q=p)==
- 初始化指针的三种方式：int *q=0;/int *q=nullptr;/int *q=NULL。==以后指针和引用的修饰符和变量挨着，而不是基本数据类型挨着==
- void* 指针，可以和别的指针比较，作为输入输出，赋值等，但是不能对其所指向1的对象操作，不知道其成员。
- 一般而言，static和const对象只在本文件可见，想在多文件可见，使用extern关键字。
- 顶层和底层const，靠近变量的是顶层const，靠近数据类型的是底层const。对指针来说，顶层const存在，则不可以改变指针的地址，即p不能变。底层const则表明指针p指向的变量不可以改变，但是指针1p本身的地址可以改变，既可以指向另外的变量。
- 常量表达式指的是值不会改变且在编译过程就能获得结果的表达式。constexpr用来显示声明变量为常量表达式
- constexpr修饰的指针和引用初始化比较严格，适用于使用全局/静态变量等固定地址来进行初始化。constexpr int *q=nullptr;将指针q初始化为空，而且constexpr修饰，这样就是一个顶层const，q的地址不可修改。
- typedef double wages，*p;using SI=int;这两个是类型别名，其中p是double *。 
- auto一般会忽略顶层const，但是如果是auto&时，则会保留顶层const的特性。
- decltype类型指示符，decltype(f()) sum=x;f()为变量时，返回变量1类型（包括顶层const和引用）。引用从来都是变量别名，除了在decltype这里。f()为表达式，则返回类型为表达式结果类型。特别注重*p，指针解引用的类型实质为对应基本数据类型的引用（因为*p作用和其一样）。当decltype里有两层括号时，结果永远是一个引用。
# 第三章 字符串，向量和数组。